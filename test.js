// 第一题

// 一天小C在参加算法比赛，这场比赛共有N道题目，小C在这场比赛中共完成了M次提交，但是网站出现了未知问题，导致排行榜无法打开，但是小C特别想知道自己通过的题目数量和总罚时，所以请你来帮他算一下。

// 已知每道题的罚时计算方式如下：每次提交的判定有两种（AC和WA），AC表示该题通过，WA表示答案错误，假设在某一题第一次获得AC判定的时间点为t，在t之前该题有k次WA判定，则罚时=t+20*k。若一题在整场比赛中都没获得AC判定，则不计该题的罚时。

// 现在给出每条提交记录的时间、题目和其对应的判定，请你帮忙计算通过的题数和总罚时。

// 输入描述
// 第一行两个正整数n和m，表示题目数量和提交次数。

// 第二行为m个正整数t1, t2,...... tm，其中ti表示第i条提交记录的时间为ti。

// 第三行为m个正整数id1, id2,...... idm，其中idi表示第i条提交的题目编号为idi。

// 第四行为m个字符串s1, s2,...... sm，其中si表示第i次提交的判定，si=“AC”或“WA”（不包含引号）。

// 输出描述
// 输出两个正整数，分别为通过的题数和总罚时。


// 样例输入
// 3 7
// 5 3 1 4 2 6 7
// 1 1 1 2 2 2 3
// AC WA WA AC WA WA WA
// 样例输出
// 2 69

// 提示
// 数据范围和说明

// 1 ≤ n ≤30000, 1 ≤ m ≤ 30000, 1 ≤ ti ≤100000, 1 ≤ idi ≤ n, 且数据保证ti各不相同。



// 样例说明

// 对于题目1，第一次获得AC的提交为提交1，提交时间为5，在这之前获得WA的次数为2次，罚时为5+20*2=45。

// 对于题目2，第一次获得AC的提交为提交4，提交时间为4，在这之前获得WA的次数为1次，罚时为4+20*1=24，提交6虽然是题目2的提交且判定为WA，但其时间位于第一次AC之后，所以不计入罚时。

// 对于题目3，未获得AC提交，不计算罚时。

// 综上通过的题目为1和2，共2题，总罚时为45+24=69 。


// 第二题
// 矩阵
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 有一个n行m列的01矩阵，矩阵中的每个元素只能为0或者1。

// 你可以选定矩阵的若干行和若干列（也可以不选），并将选定行和选定列上所有的元素全部赋为0。

// 问有多少种选定方式使得操作后的矩阵中只有k个元素为1？两种选择方式不同当且仅当某一行或者某一列在其中一种方式中被选中，但在另一种方式中未被选中。



// 输入描述
// 第一行输入三个整数n, m, k。

// 接下来n行，每行输入一个长度为m的仅含‘0’,‘1’的字符串，表示该01矩阵的第i行。

// 输出描述
// 输出一个整数，表示可行的方案数。


// 样例输入
// 3 2 2
// 10
// 01
// 11
// 样例输出
// 6

// 提示
// 数据范围和说明

// 1 ≤ n, m ≤ 8，0 ≤ k ≤ n*m



// 样例说明

// 可行的方案有：

// 1. 第一列清零

// 2. 第二列清零

// 3. 第一行和第一列清零

// 4. 第二行和第二列清零

// 5. 第一行和第二行清零

// 6. 第三行清零





// 第三题

// 减法
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 小明正在玩一个游戏，游戏开始时有一个数N，在每回合中他可以进行如下操作：

// 1． 选择一个正整数x∈[1, K]

// 2． 令N变为N-x

// 3． 如果N=0，游戏胜利

// 小明对数字d（某个阿拉伯数字）非常讨厌，所以他不希望在游戏中见到太多d这个数字，如果在任意时刻，N或x中有至少2位为d，他会直接退出游戏（视为失败）。例如d=1时，他能接受类似234、1234等数字，但当他见到1123或1141等数字时会直接退出，因为这些数都包含至少2个1。现在请你帮他计算一下，最少需要多少个回合他才能获得胜利。



// 输入描述
// 第一行三个正整数N、K和d，表示游戏开始的数字、选择正整数的范围和不喜欢的数字。

// 输出描述
// 输出至少需要多少回合才能获得胜利，如果无法胜利，则输出-1。


// 样例输入
// 5 2 1
// 样例输出
// 3

// 提示
// 输入样例2

// 11 2 1

// 输出样例2

// -1



// 数据范围和说明

// 1 ≤ n ≤ 5000, 1 ≤ K ≤ 1000, 0 ≤ d ≤ 9。



// 样例说明

// 样例1中，第一回合选择2，N变为3，第二回合选择2，N变为1，第三回合选择1，N变为0，共三回合。

// 样例2中，第一回合开始时N=11，其中有2个1，小明会直接退出游戏，无法获得胜利。

let arr = read_line().trim().split(" ").map(i=>parseInt(i))

let [n,k,d] = arr

function fn(n,k,cont,d){
  if(!valid(n,d)){
    return -1
  }
  if(n<1){
    return cont
  }else if(n<=k){
    return ++cont
  }else{
    while(k){
      let aa = fn(n-k,k,++cont,d) 
      if(aa != -1){
        return aa
      }
      k--
    }
    return cont
  }
}

function valid(n,d){
  let str = (n+"").split("")
  let s = d+""
  let len = str.filter(i=>i===s).length
  if(len>1){
    return false
  }
  return true
}


print(fn(n,k,0,d))


// 第四题
//训练
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 在遥远的国度有一位国王，在他手下有一支战无不胜的军队，但是他觉得这还不够，他决定继续通过训练提升军队的实力。军队中共有n名战士，其中第i位的战斗力为ai。在第i次训练中，国王会先找出战斗力最低的战士，
// 假设他的战斗力为x，则国王会同时训练所有战斗力为x的战士，将他们的战力都提升bi (从x变为x + bi)，这样的训练一共会进行m次。同时，为了时刻了解军队的情况，国王请你帮他计算一下，在每次训练后所有战士的战斗力之和为多少。



// 输入描述
// 第一行两个正整数n和m，表示战士数量和训练次数。

// 第二行为n个正整数a1, a2,...... an (1 ≤ ai ≤ n)，其中ai表示第i个战士初始的战斗力为ai。

// 第三行为m个正整数b1, b2,...... bm，其中bi表示第i次训练后战士战斗力增加值为bi。

// 输出描述
// 输出一行m个正整数s1, s2,...... sm，其中si表示第i次训练后所有战士的战斗力之和。


// 样例输入
// 4 2
// 1 1 2 3
// 1 3
// 样例输出
// 9 18

// 提示
// 数据范围和说明

// 1 ≤ n ≤ 50000, 1 ≤ m ≤ 40000, 1 ≤ bi ＜ 105, 且保证每次训练后每个士兵的战斗力都不会超过2×105。



// 样例说明

// 第一次训练后，战斗力为1的战士的战斗力全都变成1+1=2，所有战士战斗力分别为2、2、2、3，总和为9。第二次训练后，战斗力为2的战士的战斗力全都变成2+3=5，所有战士战斗力分别为5、5、5、3，总和为18。


// 第五题
// 积木
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 小明在玩积木。他将n块积木从左到右排成了一排，每块积木的底面积都相同，但高度有所不同。并且每块积木要么是纯黑色的，要么是纯白色的。现在小明想从中抽出一些积木，使得剩下的积木满足以下两个要求之一：

// ·剩下的积木的颜色都相同，并且高度从左向右严格递增。

// ·剩下的积木可以被分成这样的两个部分：左边部分都是黑色的，右边部分都是白色的（左边部分和右边部分的积木数量不必相同），并且黑白两个部分的积木高度都是从左向右严格递增的。

// 请问小明至少需要抽出多少块积木？



// 输入描述
// 第一行一个正整数n，表示有n块积木从左向右排成一排。

// 第二行n个数，第i个数a[i]表示从左向右第i个积木的高度。

// 第三行n个数，第i个数c[i]表示从左向右第i个积木的颜色，c[i]=0表示颜色为白，c[i]=1表示颜色为黑。

// 输出描述
// 一行，一个整数，表示小明至少需要抽出的积木数量。


// 样例输入
// 6
// 1 1 2 2 3 3
// 1 0 1 0 0 1
// 样例输出
// 2

// 提示

// 数据范围和说明

// n<=100000, a[i]<=20000, 0<=c[i]<=1



// 样例解释1

// 可以选择抽出第3个和第6个积木，剩下的4个积木是1(黑)、1(白)、2(白)、3(白)，符合要求。



// 输入样例2

// 6

// 1 3 2 2 1 3

// 0 1 0 1 1 0

// 输出样例2

// 3

// 样例解释2

// 可以选择抽出第2、4、5个积木，剩下的3个积木是1(白)、2(白)、3(白)，符合要求。

// 也可以选择抽出第1、4、5个积木，剩下的3个积木是3(黑)、2(白)、3(白)，符合要求。



// 输入样例3

// 6

// 1 3 2 2 1 3

// 1 0 1 0 0 1

// 输出样例3

// 3

// 样例解释3

// 可以选择抽出第2、4、5个积木，剩下的3个积木是1(黑)、2(黑)、3(黑)，符合要求。

// 也可以选择抽出第2、5、6个积木，剩下的3个积木是1(黑)、2(黑)、2(白)，符合要求
=======
//agagaagagagagaagg

//呱呱啊
>>>>>>> 2c65266980a81ab6524496241951ea0760c745c8
